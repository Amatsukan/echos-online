<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMORPG de Browser - Cliente</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        /* --- RESET BÁSICO --- */
        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: sans-serif;
            color: white;
            overflow: hidden; /* Impede barras de scroll na página inteira */
        }
        /* Remove a margem padrão dos títulos */
        h1, h2, p {
            margin: 0;
        }

        /* --- LAYOUT PRINCIPAL (CSS GRID) --- */
        .main-layout {
            display: grid;
            /* Colunas: Menu (fixo), Jogo (flexível), Sidebar (fixo) */
            grid-template-columns: 200px 1fr 250px;
            /* Linhas: Conteúdo Principal (flexível), Chat (fixo) */
            grid-template-rows: 1fr auto;
            height: 100vh;
            width: 100vw;
        }

        /* --- COLUNA DA ESQUERDA (MENU) --- */
        .menu-left {
            grid-column: 1;
            grid-row: 1;
            background: #2a2a2a;
            border-right: 2px solid #444;
            padding: 15px;
            overflow-y: auto; /* Scroll se tiver muitos botões */
        }
        .menu-left h1 {
            font-size: 1.5em;
            text-align: center;
            margin-bottom: 15px;
        }
        .menu-button {
            background-color: #333;
            border: 2px solid red; /* Mantive a borda vermelha, podes mudar */
            color: red; /* Mantive a cor vermelha */
            font-weight: bold;
            width: 100%;
            height: 60px; /* Reduzi um pouco a altura para caber mais botões */
            margin-bottom: 15px; /* Reduzi a margem */
            cursor: pointer;
            font-size: 1em; /* Reduzi um pouco a fonte */
            transition: background-color 0.2s;
            display: flex; /* Para centralizar o texto verticalmente */
            justify-content: center;
            align-items: center;
            text-align: center; /* Garante centralização horizontal */
        }
        .menu-button:hover {
            background-color: #444;
        }

        /* --- COLUNA CENTRAL (JOGO) --- */
        .game-center {
            grid-column: 2;
            grid-row: 1;
            padding: 0; /* Jogo ocupa todo o espaço */
            overflow: hidden;
            background: #000; /* Fundo preto caso o phaser demore a carregar */
        }
        #game-container {
            padding-top: 2%;
            padding-left: 5%;
            width: 90%;
            height: 90%;
            border: none;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
        }

        /* --- COLUNA DA DIREITA (SIDEBAR) --- */
        .sidebar-right {
            grid-column: 3;
            grid-row: 1;
            background: #2a2a2a;
            border-left: 2px solid #444;
            padding: 10px;
            overflow-y: auto;
        }
        .sidebar-right h2 {
            font-size: 1.2em;
            text-align: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        /* Grelha de Equipamentos/Status (Layout Tibia) */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* 3 colunas */
            gap: 5px; /* Espaço entre slots */
            margin-bottom: 15px;
        }

        .equip-slot {
            width: 100%; /* Ocupa a célula da grelha */
            height: 0;
            padding-bottom: 100%; /* Truque para manter o rácio 1:1 */
            position: relative;
            background-color: #333;
            border: 2px solid #444;
            border-radius: 5px;
            cursor: help;
            box-sizing: border-box;
        }
        .equip-slot-content {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 11px; /* Tamanho pequeno para nome de item */
            color: #ddd;
            font-weight: bold;
            text-align: center;
            padding: 4px;
            word-break: break-word;
        }
        .equip-slot:hover {
            border-color: #888;
        }
        
        /* Barras de HP/Mana */
        .status-bars {
            margin-bottom: 15px;
            padding: 5px;
            background: #222;
            border: 2px solid #444;
            border-radius: 5px;
        }
        .bar-container {
            width: 100%;
            height: 15px;
            background-color: #111;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 2px;
            box-sizing: border-box;
        }
        .bar-container.hp-bar { margin-bottom: 5px; }
        
        .hp-bar div {
            height: 100%;
            background-color: #ff0000; /* Vermelho */
            border-radius: 3px;
            transition: width 0.3s ease; /* Animação */
        }
        .mana-bar div {
            height: 100%;
            background-color: #0000ff; /* Azul */
            border-radius: 3px;
            transition: width 0.3s ease; /* Animação */
        }

        /* Grelha da Mochila */
        .backpack-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 colunas */
            gap: 5px;
        }
        .backpack-slot {
             width: 100%;
            height: 0;
            padding-bottom: 100%; /* Rácio 1:1 */
            background-color: #333;
            border: 2px solid #444;
            border-radius: 5px;
            position: relative; /* Para posicionar o conteúdo */
        }
         .backpack-slot-content {
             position: absolute;
             top: 4px; left: 4px; right: 4px; bottom: 4px;
             display: flex;
             justify-content: center;
             align-items: center;
             text-align: center;
             font-size: 11px;
             font-weight: bold;
             color: #ddd;
             word-break: break-word;
        }
        .backpack-slot:hover {
            border-color: #888;
        }

        /* --- LINHA INFERIOR (CHAT) --- */
        .chat-area {
            grid-column: 1 / 4; /* Ocupa as 3 colunas */
            grid-row: 2;
            background: #2a2a2a;
            border-top: 2px solid #444;
            padding: 10px;
        }
        .chat-tabs {
            margin-bottom: 5px;
        }
        .chat-tabs button {
            background: #444;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-bottom: 2px solid transparent; 
        }
        .chat-tabs button.active {
            background: #555;
            border-bottom: 2px solid #007bff;
        }
        .chat-messages {
            background-color: #1a1a1a;
            height: 80px;
            border: 1px solid #444;
            padding: 5px;
            overflow-y: scroll;
            margin-bottom: 5px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .chat-messages p {
            margin-bottom: 3px;
            word-wrap: break-word;
        }
        .chat-messages p strong {
            color: #00aaff; 
        }
        .chat-messages p.global-chat strong {
            color: #ffb700; 
        }
        .chat-messages p.global-chat {
            color: #f0f0f0; 
        }

        .chat-input-area {
            display: flex;
        }
        .chat-input-area label {
            margin-right: 10px;
            flex-shrink: 0;
            padding-top: 5px;
            font-style: italic;
            color: #aaa;
        }
        .chat-input-area input {
            width: 100%;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #333;
            color: white;
        }
        .send-chat-msg {
            background: #007bff;
            border: none;
            color: white;
            padding: 0 10px;
            margin-left: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .send-chat-msg:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>

    <script>
        // (Script de verificação do sessionStorage - Sem alterações)
        const accountInfoString = sessionStorage.getItem('accountInfo');
        const selectedCharacterString = sessionStorage.getItem('selectedCharacter');
        
        let accountInfo; 
        let selectedCharacter; 

        if (!accountInfoString || !selectedCharacterString) {
            console.error("Não foi possível encontrar accountInfo ou selectedCharacter na sessão.");
            window.location.href = 'character-select.html';
        } else {
            try {
                accountInfo = JSON.parse(accountInfoString); 
                selectedCharacter = JSON.parse(selectedCharacterString);
                console.log(`Entrando no mundo como ${selectedCharacter.name} (Conta: ${accountInfo.username})`);
            } catch (e) {
                console.error("Erro ao fazer parse dos dados da sessão:", e);
                window.location.href = 'login.html';
            }
        }
    </script>


    <div class="main-layout">
        
        <nav class="menu-left">
            <h1>menu</h1>
            <button class="menu-button" onclick="alert('Funcionalidade ainda não implementada!')">Skills</button>
            <button class="menu-button" id="btn-atributos">Atributos</button>
            <button class="menu-button" onclick="alert('Funcionalidade ainda não implementada!')">Quests</button>
            
            <button 
                class="menu-button" 
                onclick="window.location.href='/character-select.html'"
                style="border-color: yellow; color: yellow;"> 
                Seleção de Char
            </button>
            <button 
                class="menu-button" 
                onclick="sessionStorage.removeItem('accountInfo'); sessionStorage.removeItem('selectedCharacter'); window.location.href='/login.html';"
                style="border-color: orange; color: orange;"> 
                Logoff
            </button>
        </nav>

        <div class="game-center">
            <div id="game-container"></div>
            </div>

        <aside class="sidebar-right">
            <h2>Equipamentos</h2>
            
            <div class="stats-grid">
                <div class="equip-slot" title="colar/joia de pescoço/rosto">
                    <div class="equip-slot-content" id="equip-slot-8"></div>
                </div>
                <div class="equip-slot" title="item de cabeça">
                    <div class="equip-slot-content" id="equip-slot-1"></div>
                </div>
                <div class="equip-slot" title="capa/manto">
                    <div class="equip-slot-content" id="equip-slot-5"></div>
                </div>
                <div class="equip-slot" title="mão principal">
                    <div class="equip-slot-content" id="equip-slot-9"></div>
                </div>
                <div class="equip-slot" title="item de peitoral/core">
                    <div class="equip-slot-content" id="equip-slot-2"></div>
                </div>
                <div class="equip-slot" title="mão secundária">
                    <div class="equip-slot-content" id="equip-slot-6"></div>
                </div>
                <div class="equip-slot" title="local auxiliar 2 (para orbes, pederneira, flechas...)">
                    <div class="equip-slot-content" id="equip-slot-0"></div>
                </div>
                <div class="equip-slot" title="item de pernas">
                    <div class="equip-slot-content" id="equip-slot-3"></div>
                </div>
                <div class="equip-slot" title="local auxiliar 1 (para orbes, pederneira, flechas...)">
                    <div class="equip-slot-content" id="equip-slot-7"></div>
                </div>
                <div class="equip-slot" title="item de pé">
                    <div class="equip-slot-content" id="equip-slot-4"></div>
                </div>
            </div>

            <div class="status-bars">
                <div class="bar-container hp-bar">
                    <div id="hp-bar-fill" style="width: 0%;"></div> 
                </div>
                <div class="bar-container mana-bar">
                    <div id="mp-bar-fill" style="width: 0%;"></div> 
                </div>
            </div>

            <h2>Mochila</h2>
            <div class="backpack-grid" id="backpack-container">
                </div>
        </aside>

        <div class="chat-area">
            <div class="chat-tabs">
                <button id="chat-tab-local" class="active">Local</button>
                <button id="chat-tab-global">Global</button>
            </div>
            <div class="chat-messages" id="chat-messages">
                </div>
            <div class="chat-input-area">
                <label id="chat-label">Local:</label> 
                <input type="text" id="chat-input" placeholder="Digite sua mensagem...">
                <button class="send-chat-msg" id="chat-send-button">send</button>
            </div>
        </div>
    </div>


    <script>
        let TILE_SIZE = 32; 
        
        const MOVEMENT_COOLDOWN_MS = 250;
        const SPEECH_BUBBLE_DURATION = 5000; 
        
        const gameContext = {
            player: null,
            otherPlayers: new Map(), 
            socket: null,
            map: null,
            tileSize: 32,
            isMoving: false,       
            movementTask: null,
            speechBubbles: new Map()
        };

        const config = {
            type: Phaser.AUTO,
            scale: {
                mode: Phaser.Scale.RESIZE,
                parent: 'game-container',
                width: '100%',
                height: '100%'
            },
            pixelArt: true,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 }
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        function preload() {
            // Textura da Relva (Grama)
            const graphics = this.make.graphics({ x: 0, y: 0, add: false });
            graphics.fillStyle(0x228B22, 1);
            graphics.fillRect(0, 0, 32, 32);
            graphics.lineStyle(1, 0x006400, 0.5);
            graphics.strokeRect(0, 0, 32, 32);
            graphics.generateTexture('tile_grass', 32, 32);
            
            // Textura do Jogador (Azul)
            const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });
            playerGraphics.fillStyle(0x0000ff, 1);
            playerGraphics.fillRect(8, 8, 16, 16);
            playerGraphics.generateTexture('player_sprite', 32, 32);
            
            // Textura para os outros jogadores (Vermelho)
            const otherPlayerGraphics = this.make.graphics({ x: 0, y: 0, add: false });
            otherPlayerGraphics.fillStyle(0xff0000, 1); // Vermelho
            otherPlayerGraphics.fillRect(8, 8, 16, 16);
            otherPlayerGraphics.generateTexture('other_player_sprite', 32, 32);
            
            graphics.destroy();
            playerGraphics.destroy();
            otherPlayerGraphics.destroy();
        }

        function create() {
            gameContext.socket = io('http://localhost:3000');
            gameContext.scene = this;
            gameContext.isMoving = false; 

            // --- Ouvintes de Socket ---
            gameContext.socket.on('map:load', (data) => {
                console.log('Recebendo mapa do servidor...');
                 // DEBUG: Vê como são os dados recebidos
                // console.log('Dados do Mapa:', data.mapData); 
                
                gameContext.tileSize = data.tileSize;
                TILE_SIZE = data.tileSize;

                // 1. Cria o mapa a partir dos dados recebidos
                const map = this.make.tilemap({ data: data.mapData, tileWidth: TILE_SIZE, tileHeight: TILE_SIZE });
                
                // 2. Adiciona a imagem 'tile_grass' (definida no preload) como um tileset para o mapa.
                //    >>> GARANTE QUE O PRIMEIRO 'tile_grass' AQUI É IDÊNTICO AO DO preload() <<<
                const tileset = map.addTilesetImage('tile_grass', 'tile_grass'); 

                // --- (NOVO) VERIFICAÇÃO DO TILESET ---
                if (!tileset) {
                    console.error("### ERRO CRÍTICO: Falha ao adicionar o tileset 'tile_grass'. Verifica se o nome da textura ('tile_grass') no preload() está correto e se a textura foi gerada sem erros! ###");
                    return; 
                }
                console.log("Tileset 'tile_grass' adicionado com sucesso.");
                // --- FIM DA VERIFICAÇÃO ---

                // 3. Cria a camada visual.
                const layer = map.createLayer(0, tileset, 0, 0); 

                 if (!layer) {
                    console.error("### ERRO CRÍTICO: Falha ao criar a camada do mapa (createLayer falhou). Isto geralmente acontece se o tileset ('tile_grass') não foi carregado corretamente. Verifica os logs acima. ###");
                    return;
                 }
                 console.log("Camada do mapa criada com sucesso.");
                
                gameContext.map = map; 

                // Ajusta os limites
                this.physics.world.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
                this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
            });
            gameContext.socket.on('player:spawn', (data) => {
                // DEBUG: Verifica os dados recebidos para o spawn
                console.log('Dados recebidos para player:spawn:', data); 
                if (typeof data.x === 'undefined' || typeof data.y === 'undefined' || data.x === null || data.y === null) {
                     console.error("### ERRO: Dados de spawn inválidos recebidos do servidor! x ou y estão undefined ou null. ###", data);
                     // Poderíamos tentar usar uma posição padrão segura aqui, como (24, 24) * TILE_SIZE
                     // const safeSpawnX = 24 * TILE_SIZE + (TILE_SIZE / 2);
                     // const safeSpawnY = 24 * TILE_SIZE + (TILE_SIZE / 2);
                     // Por agora, apenas logamos e retornamos para evitar mais erros.
                     return; 
                }

                console.log(`Spawning em ${data.x}, ${data.y}`);
                const spawnX = (data.x * TILE_SIZE) + (TILE_SIZE / 2);
                const spawnY = (data.y * TILE_SIZE) + (TILE_SIZE / 2);
                const player = this.physics.add.sprite(spawnX, spawnY, 'player_sprite');
                player.setCollideWorldBounds(true);
                this.cameras.main.startFollow(player);
                gameContext.player = player; 
            });
            gameContext.socket.on('player:move:success', (data) => {
                if (!gameContext.player) return;
                const newX = (data.x * TILE_SIZE) + (TILE_SIZE / 2);
                const newY = (data.y * TILE_SIZE) + (TILE_SIZE / 2);
                gameContext.player.setPosition(newX, newY);
            });
            gameContext.socket.on('player:move:fail', (data) => {
                console.warn(`Movimento falhou para ${data.x}, ${data.y}. Obstáculo.`);
                gameContext.movementTask = null;
            });
            gameContext.socket.on('player:new', (data) => {
                 // DEBUG: Verifica os dados recebidos para o novo jogador
                console.log('Dados recebidos para player:new:', data);
                if (typeof data.x === 'undefined' || typeof data.y === 'undefined' || data.x === null || data.y === null) {
                    console.error("### ERRO: Dados inválidos recebidos para player:new! x ou y estão undefined ou null. ###", data);
                    return;
                }
                console.log(`Novo jogador entrou: ${data.characterId} em ${data.x}, ${data.y}`);
                const spawnX = (data.x * TILE_SIZE) + (TILE_SIZE / 2);
                const spawnY = (data.y * TILE_SIZE) + (TILE_SIZE / 2);
                const otherPlayer = this.add.sprite(spawnX, spawnY, 'other_player_sprite');
                gameContext.otherPlayers.set(data.characterId, otherPlayer);
            });
            gameContext.socket.on('player:moved', (data) => {
                const playerToMove = gameContext.otherPlayers.get(data.characterId);
                if (playerToMove) {
                    if (typeof data.x === 'number' && typeof data.y === 'number') {
                        const newX = (data.x * TILE_SIZE) + (TILE_SIZE / 2);
                        const newY = (data.y * TILE_SIZE) + (TILE_SIZE / 2);
                        playerToMove.setPosition(newX, newY);
                    } else {
                        console.warn('Dados inválidos recebidos para player:moved', data);
                    }
                }
            });
            gameContext.socket.on('player:quit', (data) => {
                console.log(`Jogador saiu: ${data.characterId}`);
                destroySpeechBubble(data.characterId);
                const playerToDestroy = gameContext.otherPlayers.get(data.characterId);
                if (playerToDestroy) {
                    playerToDestroy.destroy();
                    gameContext.otherPlayers.delete(data.characterId);
                }
            });
            gameContext.socket.on('player:spoke', (data) => {
                createSpeechBubble(data.characterId, data.message);
            });


            // --- INPUTS ---
            this.wasd = this.input.keyboard.addKeys('W,A,S,D');
            this.input.on('pointerdown', (pointer) => {
                if (pointer.button !== 0) return; 
                const worldPoint = pointer.positionToCamera(this.cameras.main);
                const targetTileX = Math.floor(worldPoint.x / TILE_SIZE);
                const targetTileY = Math.floor(worldPoint.y / TILE_SIZE);
                console.log(`Nova tarefa de movimento: ir para [${targetTileX}, ${targetTileY}]`);
                gameContext.movementTask = { x: targetTileX, y: targetTileY };
            });
            const chatInput = document.getElementById('chat-input');
            let isChatFocused = false; 
            chatInput.addEventListener('focus', () => {
                console.log('Chat Focado - Teclado Phaser desativado');
                isChatFocused = true;
                this.input.keyboard.disableGlobalCapture(); 
            });
            chatInput.addEventListener('blur', () => {
                console.log('Chat Perdeu Foco - Teclado Phaser ativado');
                isChatFocused = false;
                this.input.keyboard.enableGlobalCapture(); 
            });
            this.input.keyboard.on('keydown-SPACE', (event) => {
                if (!isChatFocused) { 
                    event.preventDefault(); 
                    chatInput.focus();      
                }
            });
        }

        // --- Funções de Balão de Fala ---
        function getPlayerSprite(characterId) {
            if (selectedCharacter && selectedCharacter.id === characterId) {
                return gameContext.player;
            }
            return gameContext.otherPlayers.get(characterId);
        }
        function destroySpeechBubble(characterId) {
            if (gameContext.speechBubbles.has(characterId)) {
                gameContext.speechBubbles.get(characterId).destroy();
                gameContext.speechBubbles.delete(characterId);
            }
        }
        function createSpeechBubble(characterId, message) {
            destroySpeechBubble(characterId);
            const playerSprite = getPlayerSprite(characterId);
            if (!playerSprite) return; 
            const text = gameContext.scene.add.text(
                playerSprite.x, 
                playerSprite.y - TILE_SIZE, 
                message, 
                {
                    fontFamily: 'sans-serif', fontSize: '12px', color: '#000000',
                    backgroundColor: '#ffffff', padding: { x: 5, y: 3 },
                    wordWrap: { width: 150 } 
                }
            );
            text.setOrigin(0.5, 1); 
            gameContext.speechBubbles.set(characterId, text);
            gameContext.scene.time.delayedCall(SPEECH_BUBBLE_DURATION, () => {
                destroySpeechBubble(characterId);
            });
        }


        // --- FUNÇÃO UPDATE ---
        function update() {
            if (!gameContext.player || !gameContext.socket || gameContext.isMoving) {
                return; 
            }
            const currentTileX = Math.floor(gameContext.player.x / TILE_SIZE);
            const currentTileY = Math.floor(gameContext.player.y / TILE_SIZE);
            let targetX = currentTileX;
            let targetY = currentTileY;
            let moveAttempted = false; 
            if (Phaser.Input.Keyboard.JustDown(this.wasd.W)) {
                gameContext.movementTask = null; 
                targetY = currentTileY - 1;
                moveAttempted = true;
            } else if (Phaser.Input.Keyboard.JustDown(this.wasd.S)) {
                gameContext.movementTask = null;
                targetY = currentTileY + 1;
                moveAttempted = true;
            } else if (Phaser.Input.Keyboard.JustDown(this.wasd.A)) {
                gameContext.movementTask = null;
                targetX = currentTileX - 1;
                moveAttempted = true;
            } else if (Phaser.Input.Keyboard.JustDown(this.wasd.D)) {
                gameContext.movementTask = null;
                targetX = currentTileX + 1;
                moveAttempted = true;
            } 
            else if (gameContext.movementTask) {
                const taskTargetX = gameContext.movementTask.x;
                const taskTargetY = gameContext.movementTask.y;
                if (currentTileX === taskTargetX && currentTileY === taskTargetY) {
                    gameContext.movementTask = null;
                } else {
                    if (currentTileX < taskTargetX) targetX++;
                    else if (currentTileX > taskTargetX) targetX--;
                    else if (currentTileY < taskTargetY) targetY++;
                    else if (currentTileY > taskTargetY) targetY--;
                    moveAttempted = true;
                }
            }
            if (moveAttempted) {
                gameContext.isMoving = true; 
                setTimeout(() => {
                    gameContext.isMoving = false; 
                }, MOVEMENT_COOLDOWN_MS);
                gameContext.socket.emit('player:move:attempt', { x: targetX, y: targetY });
            }
            gameContext.speechBubbles.forEach((bubble, characterId) => {
                const playerSprite = getPlayerSprite(characterId);
                if (playerSprite) {
                    bubble.setPosition(playerSprite.x, playerSprite.y - TILE_SIZE);
                }
            });
        }
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- Elementos da UI (Geral) ---
            const hpBarFill = document.getElementById('hp-bar-fill');
            const mpBarFill = document.getElementById('mp-bar-fill');
            const backpackContainer = document.getElementById('backpack-container');
            const btnAtributos = document.getElementById('btn-atributos'); 
            
            // --- Elementos da UI (Chat) ---
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const chatSendButton = document.getElementById('chat-send-button');
            const chatTabLocal = document.getElementById('chat-tab-local');
            const chatTabGlobal = document.getElementById('chat-tab-global');
            const chatLabel = document.getElementById('chat-label');

            let currentChatChannel = 'local'; // Padrão é 'local'

            const equipSlots = {
                '8': document.getElementById('equip-slot-8'), '1': document.getElementById('equip-slot-1'),
                '5': document.getElementById('equip-slot-5'), '9': document.getElementById('equip-slot-9'),
                '2': document.getElementById('equip-slot-2'), '6': document.getElementById('equip-slot-6'),
                '0': document.getElementById('equip-slot-0'), '3': document.getElementById('equip-slot-3'),
                '7': document.getElementById('equip-slot-7'), 
                '4': document.getElementById('equip-slot-4')
            };

            // Função para ligar os eventos da UI ao socket
            function setupSocketUI(socket) {
                
                // --- Eventos de Conexão (Geral) ---
                socket.on('connect', () => {
                    console.log('Conectado ao servidor do mundo!');
                    
                    if (accountInfo && accountInfo.accountId) {
                        socket.emit('client:authenticate', { accountId: accountInfo.accountId });
                    }
                    
                    if (selectedCharacter && selectedCharacter.id) {
                        socket.emit('player:join', { characterId: selectedCharacter.id });
                    } else {
                        console.error("Não foi possível encontrar o ID do personagem para entrar no mundo.");
                    }
                });

                socket.on('disconnect', () => {
                    console.warn('Desconectado do servidor do mundo!');
                });

                // --- Eventos de UI (Stats, Equip, Inv) ---
                
                socket.on('player:updateStats', (stats) => {
                    console.log('Recebidos Stats:', stats);
                    if (hpBarFill && stats && typeof stats.hp === 'number' && typeof stats.maxHp === 'number' && stats.maxHp > 0) {
                        const hpPercent = Math.max(0, Math.min(100, (stats.hp / stats.maxHp) * 100)); // Garante 0-100
                        hpBarFill.style.width = `${hpPercent}%`;
                    }
                    if (mpBarFill && stats && typeof stats.mp === 'number' && typeof stats.maxMp === 'number' && stats.maxMp > 0) {
                        const mpPercent = Math.max(0, Math.min(100, (stats.mp / stats.maxMp) * 100)); // Garante 0-100
                        mpBarFill.style.width = `${mpPercent}%`;
                    }
                });

                socket.on('player:updateEquipment', (equipment) => {
                     console.log('Recebidos Equipamentos:', equipment);
                     if (equipment) { // Verifica se equipment não é null/undefined
                        // Limpa todos os slots primeiro
                        for (const slotContent of Object.values(equipSlots)) {
                            if (slotContent) { slotContent.innerText = ''; }
                        }
                        // Preenche os slots com os itens recebidos
                        for (const [slotId, itemName] of Object.entries(equipment)) {
                            const slotElement = equipSlots[slotId];
                            if (slotElement) { 
                                slotElement.innerText = itemName || ''; // Usa string vazia se itemName for null/undefined
                            }
                        }
                     }
                });

                socket.on('player:updateInventory', (inventory) => {
                    console.log('Recebido Inventário:', inventory);
                    if (backpackContainer && Array.isArray(inventory)) { // Verifica se é um array
                        backpackContainer.innerHTML = '';
                        // Garante que temos sempre 12 slots, mesmo que o array recebido seja menor
                        for(let i = 0; i < 12; i++) { 
                            const item = inventory[i]; // Pode ser null ou undefined se o array for menor que 12
                            const slot = document.createElement('div');
                            slot.className = 'backpack-slot';
                            const content = document.createElement('div');
                            content.className = 'backpack-slot-content';
                            // Verifica se o item existe e tem as propriedades necessárias
                            if (item && item.name && typeof item.quantity === 'number') { 
                                content.innerText = `${item.name}\n(x${item.quantity})`;
                            } else {
                                content.innerText = ''; // Slot vazio
                            }
                            slot.appendChild(content);
                            backpackContainer.appendChild(slot);
                        }
                    } else {
                         console.warn("Recebido inventário inválido ou elemento backpackContainer não encontrado.");
                    }
                });
                
                // --- Botão "Atributos" ---
                
                if (btnAtributos) {
                    btnAtributos.addEventListener('click', () => {
                        console.log('Pedindo atributos ao servidor...');
                        socket.emit('player:getAttributes');
                    });
                } else {
                    console.warn('O elemento "btn-atributos" não foi encontrado no HTML.');
                }
                
                socket.on('player:showAttributes', (stats) => {
                    if (stats && typeof stats.str === 'number') { // Verifica se stats é válido
                        const message = `--- Atributos Base ---\n\n` +
                                      `Força (str): ${stats.str}\n` +
                                      `Inteligência (int): ${stats.int}\n` +
                                      `Destreza (dex): ${stats.dex}\n` +
                                      `Constituição (con): ${stats.con}`;
                        alert(message);
                    } else {
                        alert('Não foi possível buscar os atributos ou os dados são inválidos.');
                    }
                });

                // --- LÓGICA DO CHAT ---

                // Função para adicionar uma mensagem ao painel
                function addChatMessage(data) {
                    // Verifica se os dados recebidos são válidos
                    if (!data || !data.senderName || !data.message || !data.channel) {
                        console.warn("Recebida mensagem de chat inválida:", data);
                        return;
                    }

                    const { senderName, message, channel } = data;
                    const p = document.createElement('p');
                    
                    if (channel === 'global') {
                        p.className = 'global-chat';
                        p.innerHTML = `[Global] <strong>${senderName}:</strong> ${message}`;
                    } else {
                        p.innerHTML = `<strong>${senderName}:</strong> ${message}`;
                    }
                    
                    // Verifica se chatMessages existe antes de adicionar
                    if(chatMessages) {
                        chatMessages.appendChild(p);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }

                // Função para enviar a mensagem
                function sendChatMessage() {
                    if(!chatInput) return; // Verifica se o input existe

                    const message = chatInput.value.trim();
                    if (message.length > 0) {
                        socket.emit('chat:send', { 
                            message: message,
                            channel: currentChatChannel 
                        });
                        chatInput.value = '';
                    }
                }

                // 1. Ouve as mensagens recebidas do servidor
                socket.on('chat:receive', (data) => {
                    addChatMessage(data);
                });

                // 2. Envia ao clicar no botão "send" (Verifica se o botão existe)
                if (chatSendButton) {
                    chatSendButton.addEventListener('click', sendChatMessage);
                }

                // 3. Envia ao pressionar "Enter" no input (Verifica se o input existe)
                if (chatInput) {
                    chatInput.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault(); 
                            sendChatMessage();
                        }
                    });
                }

                // 4. Lógica de troca de Abas (Verifica se as abas existem)
                if (chatTabLocal && chatTabGlobal && chatLabel) {
                    chatTabLocal.addEventListener('click', () => {
                        currentChatChannel = 'local';
                        chatTabLocal.classList.add('active');
                        chatTabGlobal.classList.remove('active');
                        chatLabel.textContent = 'Local:';
                    });

                    chatTabGlobal.addEventListener('click', () => {
                        currentChatChannel = 'global';
                        chatTabGlobal.classList.add('active');
                        chatTabLocal.classList.remove('active');
                        chatLabel.textContent = 'Global:';
                    });
                }
            }

            // --- Ponto de Início da UI ---
            const trySetupUI = () => {
                // Verifica se o socket do Phaser já está disponível
                if (gameContext.socket) {
                    setupSocketUI(gameContext.socket);
                } else {
                    // Se ainda não estiver, tenta novamente em 100ms
                    setTimeout(trySetupUI, 100); 
                }
            };
            // Inicia a primeira tentativa
            trySetupUI();

        });
    </script>
</body>
</html>